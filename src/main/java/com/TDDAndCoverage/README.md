# SELab_HW3


## گزارش آزمایش
### مرحله‌ی اول: در این پروژه مجموعا ۲ ایراد وجود دارد. آن‌ها را پیدا کنید، برای هرکدام تستی بنویسید که آن ایراد را تشخیص دهد، در نهایت برنامه را طوری تغییر دهید که ایرادها برطرف شده باشند.


   ایراد اول: در کلاس Library در تابع lendBook وجود دانشجو در کتابخانه بررسی نشده و می‌توان کتاب را به دانشجویی قرض داد که اصلا در لیست دانشجوهای کتابخانه وجود ندارد.
   
تست تابع lendBook قبل از برطرف کردن ایراد:
   ![Screenshot from 2024-07-24 16-45-21](https://github.com/user-attachments/assets/cdc5999c-1fa2-402c-a037-5ba6d2d67b59)
تست تابع lendBook بعد از برطرف کردن ایراد:
  ![Screenshot from 2024-07-24 16-50-42](https://github.com/user-attachments/assets/0b3346b8-cf11-4422-a86e-88ad649f11fe)


   ایراد دوم: در کلاس Library در تابع returnBook کتاب برگشتی از لیست کتاب‌های دانشجو حذف نشده است.
   
تست تابع returnBook قبل از برطرف کردن ایراد:
   ![Screenshot from 2024-07-24 16-46-41](https://github.com/user-attachments/assets/bc836355-f270-4c20-ba79-6dbd39985f82)
تست تابع returnBook بعد از برطرف کردن ایراد:
  ![Screenshot from 2024-07-24 16-51-04](https://github.com/user-attachments/assets/10d53c37-d074-4f33-b51e-7bd04dd13f1a)

### مرحله‌ی دوم: در فایل `Library.java` دو تابع جستجو وجود دارد که باید با توجه به کامنت‌های آن‌ها و با استفاده از روش TDD کاملشان کنید. برای این کار ابتدا تعدادی تست بنویسید که نیازمندی‌های این ۲ تابع را پوشش دهند، سپس ۲ تابع را به شکلی کامل کنید که همه آن‌ها پاس شوند.
  
  #### تابع searchStudents:
  گام اول: انتظارات از برنامه را به صورت unit test بنویسید.  
  نوشتن تست‌های testSearchStudentsById و testSearchStudentsByName در LibraryTest.java. این تست‌ها انتظارات ما از تابع searchStudents  را مشخص می‌کنند.
  ![](https://github.com/user-attachments/assets/7a1ab8c3-80fb-4c9d-a9ec-d2eaab28af21)
  گام دوم: test ها را compile کرده و error های آن را شناسایی کنید.  
  مشاهده می‌کنیم که خطاهای کامپایل به دلیل عدم تعریف تابع `searchStudents` و بازگرداندن null شناسایی شدند.
  ![](https://github.com/user-attachments/assets/a04ad8d8-0400-44b7-a089-766697f9aac9)
  ![](https://github.com/user-attachments/assets/b11d0378-6243-4c26-8f29-5d2b57b57c15)
  گام سوم: با اضافه کردن کد در برنامه اصلی، compile error ها را برطرف نمایید.  
  در این مرحله، با اضافه کردن تابع مورد نیاز به کلاس `Library.java`، خطاهای کامپایل را برطرف می‌کنیم.
  ![](https://github.com/user-attachments/assets/db15cd47-70d1-4ed2-935e-c0d529f02fdb)
  گام چهارم: test ها را اجرا (run) کنید تا اشکالات زمان اجرا مشخص گردد.  
  در این مرحله، تست‌ها را اجرا می‌کنیم تا خطاهای زمان اجرا شناسایی شوند. مشاهده ‌می‌کنیم که خطایی وجود ندارد.
  ![](https://github.com/user-attachments/assets/fcd7dc9d-db12-4004-bc36-fb4925681769)
  ![](https://github.com/user-attachments/assets/fbab5d7a-4ab8-4e2a-bf7f-db4c6e2ac47a)
  گام پنجم: با تغییر کد در برنامه، runtime error ها را رفع نمایید.  
  تمامی تست‌ها با موفقیت اجرا شدند و هیچ خطای زمان اجرایی وجود ندارد.

  #### تابع searchBooks:
  گام اول: انتظارات از برنامه را به صورت unit test بنویسید.
  
  نوشتن تست‌های testSearchBooksByTitle، testSearchBooksById و testSearchBooksByAuthor در LibraryTest.java. این تست‌ها انتظارات ما از تابع searchBooks  را مشخص می‌کنند.
  ![](https://github.com/user-attachments/assets/657ced6d-8a7f-4f94-ba1d-2bc034cb23a5)
  گام دوم: test ها را compile کرده و error های آن را شناسایی کنید.  
   مشاهده می‌کنیم که خطاهای کامپایل به دلیل عدم تعریف تابع `searchBooks` و بازگرداندن null شناسایی شدند.
  ![](https://github.com/user-attachments/assets/451d0bef-6f37-4ede-b68e-8d723405a1d1)
  ![](https://github.com/user-attachments/assets/a8b62e46-bb95-49e0-a071-3a25f40446ee)
  ![](https://github.com/user-attachments/assets/56872dbe-68fc-4713-8df4-575b90cd0b55)
  گام سوم: با اضافه کردن کد در برنامه اصلی، compile error ها را برطرف نمایید.  
  در این مرحله، با اضافه کردن تابع مورد نیاز به کلاس `Library.java`، خطاهای کامپایل را برطرف می‌کنیم.
  ![](https://github.com/user-attachments/assets/4a43536e-4518-45ef-b3ab-2d5d4303a929)
  گام چهارم: test ها را اجرا (run) کنید تا اشکالات زمان اجرا مشخص گردد.  
  در این مرحله، تست‌ها را اجرا می‌کنیم تا خطاهای زمان اجرا شناسایی شوند. مشاهده ‌می‌کنیم که خطایی وجود ندارد.
  ![](https://github.com/user-attachments/assets/73686792-8425-4def-8437-d2ec362e13cf)
  ![](https://github.com/user-attachments/assets/6f4b4ce7-71a6-49bf-859d-00f2a3b5dee9)
  ![](https://github.com/user-attachments/assets/5a419b97-d1b1-40d9-97fe-357473cab0c1)
  گام پنجم: با تغییر کد در برنامه، runtime error ها را رفع نمایید.  
  تمامی تست‌ها با موفقیت اجرا شدند و هیچ خطای زمان اجرایی وجود ندارد.





## پرسش‌ها


۱. روش TDD را با روش تست کردن سنتی که در آن بعد از نوشتن برنامه، تست‌ها نوشته می‌شوند، از نظر نوع پروژه‌هایی که هر یک برای آن‌ها مناسب هست، مقایسه کنید.
  
  
روش TDD برای پروژه‌هایی مناسب است که:

  ۱. با متدولوژی چابک توسعه می‌یابند و نیازمندی‌های آن به طور مستمر در حال تغییر است.
  
  ۲. کیفیت بالای کد در آن مهم است و به طور مداوم نیاز به تغییر و ریفکتور دارند زیرا در TDD نوشتن کدهای تمیز و ماژولار اهمیت دارد و این روش چرخشی باعث اصلاح پیوسته‌ی کد می‌شود.
  
  ۳. الگوریتم و منطق پیچیده‌ای دارند زیرا TDD مسئله را به بخش‌های کوچکتر و قابل تست تقسیم می‌کند.
  
  ۴. اسکوپ مشخص و سایز کوچکی دارند.


روش سنتی برای پروژه‌هایی مناسب است که:

  ۱. پیچیده و بزرگ هستند زیرا در روش سنتی می‌توان عملکرد کل سیستم را با روش‌های تست integration, functional ارزیابی کرد.
  
  ۲. نیازمندی‌های ثابت و از قبل تعیین‌شده‌ای دارند و احتمال تغییرات اساسی بسیار کم است.
  
  ۳. از ابتدا با روش TDD توسعه داده نشده‌اند و یا بسیار قدیمی هستند. (legacy system)
  
  ۴. زمان کمی برای توسعه وجود دارد و باید طی یک ددلاین فشرده‌ای تحویل داده شوند.




۲. در فرایند ایجاد نرم‌افزار هم تیم ایجاد (Development Team) و هم تیم تضمین کیفیت (QA Team) وظیفه تست نرم‌افزار را برعهده دارند. هر کدام از این تیم‌ها بیش‌تر با کدام دسته از انواع تست سروکار دارد؟ چرا؟ انواع تست ذکر شده را به طور مختصر شرح دهید.

  پاسخ:

۳. روالی ‬‫را که‬ ‫برای‬ ‫پروژه‬ ‫‪json-simle‬‬ ‫ارائه‬ ‫شد‬،‬ ‫برای‬ پروژه ای که بر روی آن مشغول هستید هم‬ ‫انجام‬ ‫دهید. برای ‫به‬ ‫دست‬‫‌آوردن‬ ‫اعداد‬ ‫پوشش‬ ‫آزمون‬ ‫کافی‬ ‫است‬ ‫بر‬ ‫روی‬ ‫پکیج‬ ‫‪java‬‬ ‫در‬ ‫مسیر‬ ‫‪test‬‬ ‫کلیک‬ ‫راست‬ ‫کرده‬ ‫و‬ ‫گزینه ‬‫‪coverage‬‬ ‫‪with‬‬ ‫‪Tests‬‬ ‫‪All‬‬ ‫‪Run‬‬ ‫را‬ ‫انتخاب‬ ‫کنید‬ ‫(نیازی‬ ‫به‬ ‫اجرای‬ ‫عادی‬ ‫پروژه‬ ‫نیست)‪.‬‬‫

  پاسخ: طبق صورت سوال، روی پوشه‌ای که می‌خواهیم تمامی تست‌های درون آن‌را اجرا کنیم، راست کلیک کرده و گزینه‌ی Run All Tests With Coverage را انتخاب می‌کنیم. در یک پنل جداگانه، نتایج تست‌ها به همراه میزان پوشش آن‌ها نمایش داده می‌شود:
  
  ![Screenshot from 2024-07-28 21-01-21](https://github.com/user-attachments/assets/20e9149b-82ce-4378-9fda-c8daf2dc869a)
  
همانطور که مشاهده می‌شود، از تمامی کلاس‌ها حداقل یک تابع فراخوانی شده است. همچنین درصد پوشش خط (که برای ما بیشتر حائز اهمیت است) در کلاس Book برابر ۸۷ درصد، در کلاس Library برابر ۷۲ درصد و در کلاس Student برابر ۶۴ درصد می‌باشد.

به منظور بررسی دقیق‌تر، گزینه‌ی Generate Coverage Report (فلش کوچک سمت چپ تصویر) را انتخاب می‌کنیم. توجه کنید که خروجی ایجاد شده در آدرس src/main/resources/coverage-reports/Q3 قرار دارد و با باز کردن فایل index.html می‌توان گزارش دقیق خطوط تست شده را مشاهده کرد. در تصویر زیر، یک نمونه از این گزارش از کلاس Student آورده شده است:

![Screenshot from 2024-07-28 21-03-07](https://github.com/user-attachments/assets/eae147be-a1f8-4214-8db0-9bb87e36dbff)

همانطور که مشاهده می‌شود، خطوط سبز رنگ تست شده‌اند و خطوط قرمز رنگ (توابع DisplayBooks و ToString) هنوز تست نشده‌اند.


۴. با افزودن بخش‌هایی به کد تست، اعداد پوشش آزمون را در مورد تمامی کلاس‌های موجود در برنامه بهبود دهید. درصد افزایش اعداد پوشش آزمون مهم نیست ولی بخش‌هایی که به کد تست اضافه می‌شوند باید معنادار باشند و صرفاً یک فراخوانی ساده کلاس یا متد، بدون استفاده در بخش‌های دیگر کد کافی نیست. 

  پاسخ: برای افزایش میزان پوشش تست‌ها، از گزارشی که در سوال قبلی ایجاد کردیم، کمک می‌گیریم. کلاس‌هایی که میزان پوشش خطوط کمتر از ۱۰۰ درصد دارند، کلاس‌های Book، Student و Library هستند، در نتیجه لازم است گزارش‌های مربوط به این سه کلاس را بررسی کنیم.

  پس از بررسی، متوجه می‌شویم که از کلاس‌های Book و Student، تنها خطوط مربوط به متدهای DisplayBooks و ToString - که هر دو متدهایی برای نمایش هستند - پوشش داده نشده‌اند. از این رو، اضافه کردن تست‌هایی که تنها نحوه‌ی نمایش دادن یک کلاس را بررسی می‌کنند، خیلی معنادار نیست. پس بهتر از تست‌هایی برای پوشش بیشتر کلاس Library بنویسیم.

  اکنون گزارش مربوط به کلاس Library را بررسی می‌کنیم. بخشی از این گزارش در تصویر زیر آمده است:

  ![Screenshot from 2024-07-28 21-02-59](https://github.com/user-attachments/assets/2bafa8bc-224f-49c4-98d9-d083dd307a00)

  همانطور که مشاهده می‌شود، خطوطی که مربوط به یک سری از شرط‌های خاص هستند، بررسی نشده‌اند. می‌توانیم برای پوشش این خطوط، تست‌هایی را اضافه کنیم:

  - تست `testBookExistenceInLendingBook`: در این تست، ابتدا یک Student را به کتابخانه اضافه می‌کنیم، ولی کتابی که می‌خواهیم به تابع lendBook بدهیم را به کتابخانه اضافه نمی‌کنیم. بنابراین در این تست، حالتی که کتاب در کتابخانه وجود نداشته باشد نیز بررسی خواهد شد. پس از اضافه کردن این تست، درصد پوشش خطوط حدود ۳ درصد افزایش می‌یابد:

![Screenshot from 2024-07-28 21-24-07](https://github.com/user-attachments/assets/64ca231c-1717-48ec-ac02-6742509be9f8)

- تست `testStudentHasBookInLendingBook`: در این تست، ابتدا یک کتاب را دو بار به کتابخانه اضافه می‌کنیم تا حداقل دو نسخه از آن در کتابخانه موجود باشد. سپس یک دانش آموز را به این کتابخانه اضافه می‌کنیم و با صدا زدن تابع lendBook، یک نسخه از این کتاب را به این دانش آموز قرض می‌دهیم. اکنون با دوباره صدا زدن این تابع، خطوط مربوط به شرطی که بررسی می‌کند آیا دانش آموز کتاب را قبلا قرض گرفته یا خیر، بررسی می‌شود. (توجه کنید که دلیل دو بار اضافه کردن کتاب، رد شدن از شرط «موجود بودن کتاب در کتابخانه» بود) با اضافه کردن این تست، درصد پوشش خطوط حدود ۴ درصد افزایش می‌یابد:

![Screenshot from 2024-07-28 21-35-13](https://github.com/user-attachments/assets/3ba4f07f-fb19-4ab1-adc4-bfaf8d65a741)

- تست `testStudentExistenceInReturningBook`: در این تست، تلاش می‌کنیم تا یک کتاب را از سمت یک دانش آموزی که در کتابخانه ثبت نام نکرده است، برگردانیم. بنابراین تابع returnBook را روی دانش آموزی که در این کتابخانه وجود ندارد صدا می‌زنیم. تابع returnBook مقدار false را برمی‌گرداند. با اضافه کردن این تست، میزان پوشش خطوط حدود ۳ درصد دیگر نیز افزایش می‌یابد:

![Screenshot from 2024-07-28 21-45-38](https://github.com/user-attachments/assets/db2b07f5-fe12-4e11-a89c-eb1ae35bf409)
